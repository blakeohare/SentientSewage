TOP_ORIGIN = [GAME_WIDTH / 2, 2 * GAME_HEIGHT / 5];

class PlayScene : AbstractScene {
	constructor() : base() {
		this.fluid = new FluidSurface(9, 9);
		this.active_bricks = [];
		this.counter = 0;
		this.last_click = -9999;
		this.last_click_coords = null;
	}
	
	function update(events) {
		origin_x = TOP_ORIGIN[0];
		origin_y = TOP_ORIGIN[1];
		for (event : events) {
			x = event.x - origin_x;
			y = event.y - origin_y + this.fluid.level * 20;
			col = (x / 2.0 + y) / 40.0;
			row = (y - x / 2.0) / 40.0;
			is_click = event.type == 'mouseleftdown';
			ignore = false;
			if (is_click) {
				if (col >= 0 && row >= 0 && col < this.fluid.width && row < this.fluid.height) {
					delay = this.counter - this.last_click;
					if (delay < FPS / 3) {
						ignore = true;
					} else if (delay < FPS * 2 / 3 && this.last_click_coords == col * 1000 + row) {
						ignore = true;
					} else {
						this.last_click = this.counter;
						this.last_click_coords = col * 1000 + row;
					}
				}
			}
			
			if (!ignore) {
				this.fluid.set_active_tile($floor(col), $floor(row), is_click);
			}
		}
		
		this.fluid.update();
		new_bricks = [];
		bricks_hit = 0;
		
		for (brick : this.active_bricks) {
			brick.update(this.fluid);
			if (brick.dead) {
				if (brick.hit_water) {
					bricks_hit++;
				}
			} else {
				new_bricks.add(brick);
			}
		}
		this.active_bricks = new_bricks;
		
		this.fluid.level -= bricks_hit * .2;
		if (this.fluid.level < .3) {
			// TODO: YOU LOSE!
			$print('lose');
		}
		
		this.fluid.level += .1 / FPS; // water level goes up .1 per second
		
		if (this.fluid.level >= this.fluid.max_level) {
			// TODO: YOU WIN!
			$print('win');
		}
		
		if (this.counter % FPS * 10 == 0) {
			x = 0.001;
			y = $random() * (this.fluid.height - 4) + 1.5;
			if ($random() < .5) {
				t = x;
				x = y;
				y = t;
			}
			
			target_x = $random() * (this.fluid.width - 4) + 1.5;
			target_y = $random() * (this.fluid.height - 4) + 1.5;
			
			this.active_bricks.add(new Brick(x, y, this.fluid.max_level + 1, target_x, target_y, this.fluid.level));
		}
		
		this.counter++;
	}
	
	function render(rc) {
		this.fluid.update_ripple(rc);
		this.fluid.render(rc, TOP_ORIGIN[0], TOP_ORIGIN[1], this.active_bricks);
	}
}
