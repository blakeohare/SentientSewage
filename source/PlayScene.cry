TOP_ORIGIN = [GAME_WIDTH / 2, 100];

class PlayScene : AbstractScene {
	constructor() : base() {
		this.fluid = new FluidSurface(9, 9);
		this.active_bricks = [];
		this.counter = 0;
		this.last_click = -9999;
		this.last_click_coords = null;
	}
	
	function update(events) {
		origin_x = TOP_ORIGIN[0];
		origin_y = TOP_ORIGIN[1];
		for (event : events) {
			x = event.x - origin_x;
			y = event.y - origin_y - this.fluid.level * 40 + 20;
			col = (x / 2.0 + y) / 40.0;
			row = (y - x / 2.0) / 40.0;
			is_click = event.type == 'mouseleftdown';
			ignore = false;
			if (is_click) {
				if (col >= 0 && row >= 0 && col < this.fluid.width && row < this.fluid.height) {
					delay = this.counter - this.last_click;
					if (delay < FPS / 3) {
						ignore = true;
					} else if (delay < FPS * 2 / 3 && this.last_click_coords == col * 1000 + row) {
						ignore = true;
					} else {
						this.last_click = this.counter;
						this.last_click_coords = col * 1000 + row;
					}
				}
			}
			
			if (!ignore) {
				this.fluid.set_active_tile($floor(col), $floor(row), is_click);
			}
		}
		
		this.fluid.update();
		new_bricks = [];
		for (brick : this.active_bricks) {
			brick.update(this.fluid);
			if (!brick.dead) {
				new_bricks.add(brick);
			}
		}
		this.active_bricks = new_bricks;
		
		if (this.counter % FPS * 5 == 0) {
			this.active_bricks.add(new Brick());
		}
		
		this.counter++;
	}
	
	function render(rc) {
		this.fluid.update_ripple(rc);
		this.fluid.render(rc, TOP_ORIGIN[0], TOP_ORIGIN[1], this.active_bricks);
	}
}
