class FluidSurface {
	constructor(width, height) {
		this.width = width;
		this.height = height;
		
		this.ripple = make_grid(width, height, 0.0);
		this.action_grid = make_grid(width, height, 0.0);
		this.active_tile_x = null;
		this.active_tile_y = null;
		
		this.level = 1.0;
	}
	
	function set_active_tile(x, y) {
		x++;
		y++;
		if (x > 0 && x < this.width && y > 0 && y < this.height) {
			this.active_tile_x = x;
			this.active_tile_y = y;
		} else {
			this.active_tile_x = null;
			this.active_tile_y = null;
		}
	}
	
	function update_ripple(rc) {
		width = this.width;
		height = this.height;
		ripple = this.ripple;
		
		// 3 random points in the grid
		pt1x = width * .35;
		pt1y = height * .35;
		pt2x = width * .80;
		pt2y = height * .20;
		pt3x = width * .63;
		pt3y = height * .71;
		
		for (y = 0; y < height; ++y) {
			for (x = 0; x < width; ++x) {
				
				dx = x - pt1x;
				dy = y - pt1y;
				func1 = $cos(.05 * rc + (dx ** 2 + dy ** 2) ** .5) * .1;
				
				dx = x - pt2x;
				dy = y - pt2y;
				func2 = $cos(.05 * rc + (dx ** 2 + dy ** 2) ** .5) * .1;
				
				dx = x - pt3x;
				dy = y - pt3y;
				func3 = $cos(.05 * rc + (dx ** 2 + dy ** 2) ** .5) * .1;
				
				ripple[x][y] = 2 * (func1 + func2 + func3);
			}
		}
	}
	
	function render(rc, origin_x, origin_y) {
		height = this.height;
		width = this.width;
		ripple = this.ripple;
		/*
			a
		  b | c
		    d(PT)
		*/
		
		for (y = 1; y < height; ++y) {
			for (x = 1; x < width; ++x) {
				az = this.level;
				bz = this.level;
				cz = this.level;
				dz = this.level;
				
				az += ripple[x - 1][y - 1];
				bz += ripple[x - 1][y];
				cz += ripple[x][y - 1];
				dz += ripple[x][y];
				
				px = origin_x + (x - y) * 40;
				py = origin_y + (x + y) * 20;
				
				if (x == this.active_tile_x && y == this.active_tile_y) {
					r = 200;
					g = 0;
					b = 0;
				} else {
					r = 0;
					g = 100;
					b = 255;
				}
				
				vertical_tilt = $arctan((az - dz));
				tilt_left = (vertical_tilt + $arctan((az - bz))) / TWO_PI_PLUS_EPSILON;
				tilt_right = (vertical_tilt + $arctan((cz - az))) / TWO_PI_PLUS_EPSILON;
				
				// make it lighter
				if (tilt_left > 0) {
					ratio = 1 - tilt_left;
					r1 = $floor(255 - (255 - r) * ratio);
					g1 = $floor(255 - (255 - g) * ratio);
					b1 = $floor(255 - (255 - b) * ratio);
				} else {
					ratio = 1 + tilt_left;
					r1 = $floor(r * ratio);
					g1 = $floor(g * ratio);
					b1 = $floor(b * ratio);
				}
				
				if (tilt_right > 0) {
					ratio = (1 - tilt_right) ** 2;
					r2 = $floor(255 - (255 - r) * ratio);
					g2 = $floor(255 - (255 - g) * ratio);
					b2 = $floor(255 - (255 - b) * ratio);
				} else {
					ratio = (1 + tilt_left) ** 2;
					r2 = $floor(r * ratio);
					g2 = $floor(g * ratio);
					b2 = $floor(b * ratio);
				}
				
				if (r1 > 255) r1 = 255;
				else if (r1 < 0) r1 = 0;
				if (g1 > 255) g1 = 255;
				else if (g1 < 0) g1 = 0;
				if (b1 > 255) b1 = 255;
				else if (b1 < 0) b1 = 0;
				
				if (r2 > 255) r2 = 255;
				else if (r2 < 0) r2 = 0;
				if (g2 > 255) g2 = 255;
				else if (g2 < 0) g2 = 0;
				if (b2 > 255) b2 = 255;
				else if (b2 < 0) b2 = 0;
				
				// left triangle: top, left, bottom
				// right triangle: top, right, bottom
				$gfx_draw_triangle(
					px, py - $floor(az * 20),
					px - 40, py - $floor(bz * 20) + 20,
					px, py - $floor(dz * 20) + 40,
					r1, g1, b1, 255);
					
				$gfx_draw_triangle(
					px, py - $floor(az * 20),
					px + 40, py - $floor(cz * 20) + 20,
					px, py - $floor(dz * 20) + 40,
					r2, g2, b2, 255);
			}
		}
	}
}
