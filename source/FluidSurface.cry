
NEIGHBORS = [];
for (dx = -3; dx <= 2; ++dx) {
	for (dy = -3; dy <= 2; ++dy) {
		mdx = dx;
		mdy = dy;
		if (mdx < 0) mdx += 1;
		if (mdy < 0) mdy += 1;
		dist = (mdx ** 2 + mdy ** 2) ** .5;
		value = 2.7182818 ** (-dist);
		if (value > 1) value = 1;
		if (value > .5) value = (value - .5) * .5 + .5;
		
		// directional vector
		vx = dx + .5;
		vy = dy + .5;
		
		NEIGHBORS.add([dx, dy, value * 1.42, [vx, vy]]);
	}
}

class FluidSurface {
	constructor(width, height) {
		this.width = width;
		this.height = height;
		
		this.action_height = [0.0] * (width * height);
		this.action_cooldown = [0] * (width * height);
		this.action_severity = [0] * (width * height);
		this.action_vector = [0] * (width * height);
		this.ripple = [0.0] * (width * height);
		
		this.active_tile_x = null;
		this.active_tile_y = null;
		
		this.level = 1.0;
	}
	
	function set_active_tile(x, y, is_click) {
		x++;
		y++;
		if (x > 0 && x < this.width && y > 0 && y < this.height) {
			this.active_tile_x = x;
			this.active_tile_y = y;
			
			if (is_click) {
				index = x + y * this.width;
				
				for (neighbor : NEIGHBORS) {
					nx = neighbor[0] + x;
					ny = neighbor[1] + y;
					if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
						index = nx + ny * this.width;
						this.action_severity[index] = neighbor[2];
						this.action_cooldown[index] = 7;
						this.action_vector[index] = neighbor[3];
					}
				}
			}
		} else {
			this.active_tile_x = null;
			this.active_tile_y = null;
		}
	}
	
	function update() {
		action_cooldown = this.action_cooldown;
		action_height = this.action_height;
		for (i = this.width * this.height - 1; i >= 0; --i) {
			if (action_cooldown[i] > 0) {
				action_cooldown[i]--;
				action_height[i] += this.action_severity[i];
			} else {
				if (action_height[i] > 0) {
					value = action_height[i] * .9;
					if (value < .1) value = 0;
					action_height[i] = value;
				}
			}
		}
	}
	
	function update_ripple(rc) {
		width = this.width;
		height = this.height;
		ripple = this.ripple;
		
		// 3 random points in the grid
		pt1x = width * .35;
		pt1y = height * .35;
		pt2x = width * .80;
		pt2y = height * .20;
		pt3x = width * .63;
		pt3y = height * .71;
		
		index = 0;
		for (y = 0; y < height; ++y) {
			for (x = 0; x < width; ++x) {
				
				dx = x - pt1x;
				dy = y - pt1y;
				func1 = $cos(.1 * rc + (dx ** 2 + dy ** 2) ** .5) * .1;
				
				dx = x - pt2x;
				dy = y - pt2y;
				func2 = $cos(.05 * rc + (dx ** 2 + dy ** 2) ** .5) * .1;
				
				dx = x - pt3x;
				dy = y - pt3y;
				func3 = $cos(.15 * rc + (dx ** 2 + dy ** 2) ** .5) * .1;
				
				ripple[index++] = 2 * (func1 + func2 + func3);
			}
		}
	}
	
	function get_action_vector_at(x, y) {
		if (x < 0 || y < 0 || x >= this.width - 1 || y >= this.height - 1) return null;
		
		col = $floor(x);
		row = $floor(y);
		index = col + row * this.width;
		
		dx = 0.0;
		dy = 0.0;
		weight = 0;
		for (index : [index, index + 1, index + this.width, index + this.width + 1]) {
			if (this.action_cooldown[index] > 0) {
				weight++;
				dxdy = this.action_vector[index];
				dx += dxdy[0];
				dy += dxdy[1];
			}
		}
		
		if (weight > 0) {
			return [dx / weight, dy / weight];
		}
		
		return null;
	}
	
	function get_action_severity_at(x, y) {
		if (x < 0 || y < 0 || x >= this.width - 1 || y >= this.height - 1) return 0;
		
		col = $floor(x);
		row = $floor(y);
		index = col + row * this.width;
		
		total = 0.0;
		weight = 0;
		
		for (index : [index, index + 1, index + this.width, index + this.width + 1]) {
			if (this.action_cooldown[index] > 0) {
				weight++;
				total += this.action_severity[index];
			}
		}
		
		if (weight > 0) {
			return total / weight;
		}
		
		return 0;
	}
		
	function get_z_at(x, y) {
		width = this.width;
		if (x < 0 || x >= this.width - 1 || y < 0 || y >= this.height - 1) {
			return this.level;
		}
		
		col = $floor(x);
		row = $floor(y);
		
		ux = x - col;
		uy = y - row;
		if (ux >= 1 || uy >= 1) {
			$assert(false, "WAT? " + ux + ', ' + uy + ', ' + x + ', ' + y);
		}
		index = col + row * width;
		values = [
			this.action_height[index] + this.ripple[index] + this.level,
			this.action_height[index + width] + this.ripple[index + width] + this.level,
			this.action_height[index + 1] + this.ripple[index + width] + this.level,
			this.action_height[index + width + 1] + this.ripple[index + width + 1] + this.level,
		];
		
		distances = [
			(ux ** 2 + uy ** 2) ** .5,
			(ux ** 2 + (1 - uy) ** 2) ** .5,
			((1 - ux) ** 2 + uy ** 2) ** .5,
			((1 - ux) ** 2 + (1 - uy) ** 2) ** .5,
		];
		
		total_value = 0.0;
		total_weight = 0.0;
		
		for (i = 0; i < 4; ++i) {
			dist = distances[i];
			if (dist < .05) return values[i];
			if (dist > 1.0) continue;
			weight = 1.0 / dist;
			total_value += values[i] * weight;
			total_weight += weight;
		}
		
		return total_value / total_weight;
	}
	
	function to_screen_coordinate(x, y, z, origin_x, origin_y) {
		return [
			$floor(origin_x + (x - y) * 40),
			$floor(origin_y + (x + y - z) * 20)
		];
	}
	
	function draw_quad(a, b, c, d, rgb) {
		alpha = rgb.length == 3 ? 255 : rgb[3];
		$gfx_draw_triangle(a[0], a[1], b[0], b[1], d[0], d[1], rgb[0], rgb[1], rgb[2], alpha);
		$gfx_draw_triangle(a[0], a[1], c[0], c[1], d[0], d[1], rgb[0], rgb[1], rgb[2], alpha);
	}
	
	function render(rc, origin_x, origin_y, active_bricks) {
		
		height = this.height;
		width = this.width;
		
		tile_width = this.width - 1;
		tile_height = this.height - 1;
		
		max_height = 6;
		
		// tank top
		/*
			 A
			B C
			 D
		*/
		top_a = this.to_screen_coordinate(-1, -1, max_height, origin_x, origin_y);
		top_b = this.to_screen_coordinate(-1, tile_height, max_height, origin_x, origin_y);
		top_c = this.to_screen_coordinate(tile_width, -1, max_height, origin_x, origin_y);
		top_d = this.to_screen_coordinate(tile_width, tile_height, max_height, origin_x, origin_y);
		this.draw_quad(top_a, top_b, top_c, top_d, [128, 128, 128]);
		
		// tank left
		/*
			A
			B C
			  D
		*/
		left_a = top_b;
		left_b = this.to_screen_coordinate(-1, tile_height, -1, origin_x, origin_y);
		left_c = top_d;
		left_d = this.to_screen_coordinate(tile_width, tile_height, -1, origin_x, origin_y);
		this.draw_quad(left_a, left_b, left_c, left_d, [100, 100, 100]);
		
		// tank right
		
		/*
			  C
			A D
			B
		*/
		right_a = top_d;
		right_b = left_d;
		right_c = top_c;
		right_d = this.to_screen_coordinate(tile_width, -1, -1, origin_x, origin_y);
		this.draw_quad(right_a, right_b, right_c, right_d, [70, 70, 70]);
		 
		// Water base
		/*
			 A
			B C
			 D
		*/
		inner_base_a = this.to_screen_coordinate(0, 0, 0, origin_x, origin_y);
		inner_base_b = this.to_screen_coordinate(0, tile_height, 0, origin_x, origin_y);
		inner_base_c = this.to_screen_coordinate(tile_width, 0, 0, origin_x, origin_y);
		inner_base_d = this.to_screen_coordinate(tile_width, tile_height, 0, origin_x, origin_y);
		this.draw_quad(inner_base_a, inner_base_b, inner_base_c, inner_base_d, [0, 0, 128]);
		
		/*
			 B
			AD
			C
		*/
		inner_left_a = this.to_screen_coordinate(0, tile_height, max_height, origin_x, origin_y);
		inner_left_b = this.to_screen_coordinate(0, 0, max_height, origin_x, origin_y);
		inner_left_c = inner_base_b;
		inner_left_d = inner_base_a;
		this.draw_quad(inner_left_a, inner_left_b, inner_left_c, inner_left_d, [60, 60, 60]);
		/*
			A
			BC
			 D
		*/
		inner_right_a = inner_left_b;
		inner_right_b = inner_left_d;
		inner_right_c = this.to_screen_coordinate(tile_width, 0, max_height, origin_x, origin_y);
		inner_right_d = inner_base_c;
		this.draw_quad(inner_right_a, inner_right_b, inner_right_c, inner_right_d, [100, 100, 100]);
		
		
		
		ripple = this.ripple;
		action_height = this.action_height;
		/*
			a
		  b | c
		    d(PT)
		*/
		
		brick_cells = {}; // index -> list of bricks
		
		for (brick : active_bricks) {
			if (!brick.dead) {
				col = $floor(brick.x);
				row = $floor(brick.y);
				if (col < 0 || row < 0 || col >= this.width || row >= this.height) {
					brick.dead = true;
				} else {
					index = col + row * this.width;
					brick_list = brick_cells.get(index, null);
					if (brick_list == null) {
						brick_list = [];
						brick_cells[index] = brick_list;
					}
					brick_list.add(brick);
				}
			}
		}
		
		deferred_shadows = [];
		//$print(this.level);
		for (y = 1; y < height; ++y) {
			index = 1 + y * width;
			for (x = 1; x < width; ++x) {
				
				a_index = index - width - 1;
				b_index = index - 1;
				c_index = index - width;
				
				az = ripple[a_index] + action_height[a_index] + this.level;
				bz = ripple[b_index] + action_height[b_index] + this.level;
				cz = ripple[c_index] + action_height[c_index] + this.level;
				dz = ripple[index] + action_height[index] + this.level;
				
				px = origin_x + (x - y) * 40;
				py = origin_y + (x + y) * 20 - 40; // -40 because coordinate A is in the tile behind the current index.
				
				if (x == this.active_tile_x && y == this.active_tile_y) {
					v = $abs((rc * 17) % 300 - 150);
					r = v;
					g = 0;
					b = 100 + v;
				} else {
					r = 0;
					g = 100;
					b = 255;
				}
				
				vertical_tilt = $arctan((az - dz));
				tilt_left = (vertical_tilt + $arctan((az - bz))) / TWO_PI_PLUS_EPSILON;
				tilt_right = (vertical_tilt + $arctan((cz - az))) / TWO_PI_PLUS_EPSILON;
				
				// make it lighter
				if (tilt_left > 0) {
					ratio = 1 - tilt_left;
					r1 = $floor(255 - (255 - r) * ratio);
					g1 = $floor(255 - (255 - g) * ratio);
					b1 = $floor(255 - (255 - b) * ratio);
				} else {
					ratio = 1 + tilt_left;
					r1 = $floor(r * ratio);
					g1 = $floor(g * ratio);
					b1 = $floor(b * ratio);
				}
				
				if (tilt_right > 0) {
					ratio = (1 - tilt_right) ** 2;
					r2 = $floor(255 - (255 - r) * ratio);
					g2 = $floor(255 - (255 - g) * ratio);
					b2 = $floor(255 - (255 - b) * ratio);
				} else {
					ratio = (1 + tilt_left) ** 2;
					r2 = $floor(r * ratio);
					g2 = $floor(g * ratio);
					b2 = $floor(b * ratio);
				}
				
				if (r1 > 255) r1 = 255;
				else if (r1 < 0) r1 = 0;
				if (g1 > 255) g1 = 255;
				else if (g1 < 0) g1 = 0;
				if (b1 > 255) b1 = 255;
				else if (b1 < 0) b1 = 0;
				
				if (r2 > 255) r2 = 255;
				else if (r2 < 0) r2 = 0;
				if (g2 > 255) g2 = 255;
				else if (g2 < 0) g2 = 0;
				if (b2 > 255) b2 = 255;
				else if (b2 < 0) b2 = 0;
				
				// left triangle: top, left, bottom
				// right triangle: top, right, bottom
				$gfx_draw_triangle(
					px, py - $floor(az * 20),
					px - 40, py - $floor(bz * 20) + 20,
					px, py - $floor(dz * 20) + 40,
					r1, g1, b1, 255);
					
				$gfx_draw_triangle(
					px, py - $floor(az * 20),
					px + 40, py - $floor(cz * 20) + 20,
					px, py - $floor(dz * 20) + 40,
					r2, g2, b2, 255);
				
				bricks = brick_cells.get(index, null);
				if (bricks != null) {
					for (brick : bricks) {
						bx = origin_x + (brick.x - brick.y) * 40;
						water_z = this.get_z_at(brick.x, brick.y);
						by_shadow = origin_y + (brick.x + brick.y) * 20 - water_z * 20;
						by = origin_y + (brick.x + brick.y - brick.z) * 20;
						shadow_height = 6 * (dz - az + 40) / 40.0;
						if (shadow_height > 0) {
							deferred_shadows.add([bx, by_shadow, shadow_height]);
						}
						
						$gfx_draw_ellipse(
							$floor(bx) - 5,
							$floor(by) - 5,
							10,
							10, 
							255, 255, 255, 255);
					}
				}
				
				++index;
			}
		}
		
		for (deferred_shadow : deferred_shadows) {
			x = deferred_shadow[0];
			y = deferred_shadow[1];
			height = deferred_shadow[2];
			width = 10;
			$gfx_draw_ellipse(
				$floor(x - width / 2),
				$floor(y - height / 2),
				width,
				$floor(height),
				0, 0, 0, 160);
		}
	}
}
