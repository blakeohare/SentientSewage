NEIGHBORS = [];
for (dx = -3; dx <= 2; ++dx) {
	for (dy = -3; dy <= 2; ++dy) {
		mdx = dx;
		mdy = dy;
		if (mdx < 0) mdx += 1;
		if (mdy < 0) mdy += 1;
		dist = (mdx ** 2 + mdy ** 2) ** .5;
		value = 2.7182818 ** (-dist);
		if (value > 1) value = 1;
		if (value > .5) value = (value - .5) * .5 + .5;
		NEIGHBORS.add([dx, dy, value * 1.42]);
	}
}

class FluidSurface {
	constructor(width, height) {
		this.width = width;
		this.height = height;
		
		this.action_height = [0.0] * (width * height);
		this.action_cooldown = [0] * (width * height);
		this.action_severity = [0] * (width * height);
		this.ripple = [0.0] * (width * height);
		
		this.active_tile_x = null;
		this.active_tile_y = null;
		
		this.level = 1.0;
	}
	
	function set_active_tile(x, y, is_click) {
		x++;
		y++;
		if (x > 0 && x < this.width && y > 0 && y < this.height) {
			this.active_tile_x = x;
			this.active_tile_y = y;
			
			if (is_click) {
				index = x + y * this.width;
				
				for (neighbor : NEIGHBORS) {
					nx = neighbor[0] + x;
					ny = neighbor[1] + y;
					if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
						index = nx + ny * this.width;
						this.action_severity[index] = neighbor[2];
						this.action_cooldown[index] = 7;
					}
				}
				
				
			}
		} else {
			this.active_tile_x = null;
			this.active_tile_y = null;
		}
	}
	
	function update() {
		action_cooldown = this.action_cooldown;
		action_height = this.action_height;
		for (i = this.width * this.height - 1; i >= 0; --i) {
			if (action_cooldown[i] > 0) {
				action_cooldown[i]--;
				action_height[i] += this.action_severity[i];
			} else {
				if (action_height[i] > 0) {
					value = action_height[i] * .9;
					if (value < .1) value = 0;
					action_height[i] = value;
				}
			}
		}
	}
	
	function update_ripple(rc) {
		width = this.width;
		height = this.height;
		ripple = this.ripple;
		
		// 3 random points in the grid
		pt1x = width * .35;
		pt1y = height * .35;
		pt2x = width * .80;
		pt2y = height * .20;
		pt3x = width * .63;
		pt3y = height * .71;
		
		index = 0;
		for (y = 0; y < height; ++y) {
			for (x = 0; x < width; ++x) {
				
				dx = x - pt1x;
				dy = y - pt1y;
				func1 = $cos(.1 * rc + (dx ** 2 + dy ** 2) ** .5) * .1;
				
				dx = x - pt2x;
				dy = y - pt2y;
				func2 = $cos(.05 * rc + (dx ** 2 + dy ** 2) ** .5) * .1;
				
				dx = x - pt3x;
				dy = y - pt3y;
				func3 = $cos(.15 * rc + (dx ** 2 + dy ** 2) ** .5) * .1;
				
				ripple[index++] = 2 * (func1 + func2 + func3);
			}
		}
	}
	
	function render(rc, origin_x, origin_y, active_bricks) {
		height = this.height;
		width = this.width;
		ripple = this.ripple;
		action_height = this.action_height;
		/*
			a
		  b | c
		    d(PT)
		*/
		
		brick_cells = {}; // index -> list of bricks
		
		for (brick : active_bricks) {
			if (!brick.dead) {
				col = $floor(brick.x);
				row = $floor(brick.y);
				if (col < 0 || row < 0 || col >= this.width || row >= this.height) {
					brick.dead = true;
				} else {
					index = col + row * this.width;
					brick_list = brick_cells.get(index, null);
					if (brick_list == null) {
						brick_list = [];
						brick_cells[index] = brick_list;
					}
					brick_list.add(brick);
				}
			}
		}
		
		for (y = 1; y < height; ++y) {
			index = 1 + y * width;
			for (x = 1; x < width; ++x) {
				az = this.level;
				bz = this.level;
				cz = this.level;
				dz = this.level;
				
				a_index = index - width - 1;
				b_index = index - 1;
				c_index = index - width;
				
				az += ripple[a_index] + action_height[a_index];
				bz += ripple[b_index] + action_height[b_index];
				cz += ripple[c_index] + action_height[c_index];
				dz += ripple[index] + action_height[index];
				
				px = origin_x + (x - y) * 40;
				py = origin_y + (x + y) * 20;
				
				if (x == this.active_tile_x && y == this.active_tile_y) {
					r = 200;
					g = 0;
					b = 0;
				} else {
					r = 0;
					g = 100;
					b = 255;
				}
				
				vertical_tilt = $arctan((az - dz));
				tilt_left = (vertical_tilt + $arctan((az - bz))) / TWO_PI_PLUS_EPSILON;
				tilt_right = (vertical_tilt + $arctan((cz - az))) / TWO_PI_PLUS_EPSILON;
				
				// make it lighter
				if (tilt_left > 0) {
					ratio = 1 - tilt_left;
					r1 = $floor(255 - (255 - r) * ratio);
					g1 = $floor(255 - (255 - g) * ratio);
					b1 = $floor(255 - (255 - b) * ratio);
				} else {
					ratio = 1 + tilt_left;
					r1 = $floor(r * ratio);
					g1 = $floor(g * ratio);
					b1 = $floor(b * ratio);
				}
				
				if (tilt_right > 0) {
					ratio = (1 - tilt_right) ** 2;
					r2 = $floor(255 - (255 - r) * ratio);
					g2 = $floor(255 - (255 - g) * ratio);
					b2 = $floor(255 - (255 - b) * ratio);
				} else {
					ratio = (1 + tilt_left) ** 2;
					r2 = $floor(r * ratio);
					g2 = $floor(g * ratio);
					b2 = $floor(b * ratio);
				}
				
				if (r1 > 255) r1 = 255;
				else if (r1 < 0) r1 = 0;
				if (g1 > 255) g1 = 255;
				else if (g1 < 0) g1 = 0;
				if (b1 > 255) b1 = 255;
				else if (b1 < 0) b1 = 0;
				
				if (r2 > 255) r2 = 255;
				else if (r2 < 0) r2 = 0;
				if (g2 > 255) g2 = 255;
				else if (g2 < 0) g2 = 0;
				if (b2 > 255) b2 = 255;
				else if (b2 < 0) b2 = 0;
				
				// left triangle: top, left, bottom
				// right triangle: top, right, bottom
				$gfx_draw_triangle(
					px, py - $floor(az * 20),
					px - 40, py - $floor(bz * 20) + 20,
					px, py - $floor(dz * 20) + 40,
					r1, g1, b1, 255);
					
				$gfx_draw_triangle(
					px, py - $floor(az * 20),
					px + 40, py - $floor(cz * 20) + 20,
					px, py - $floor(dz * 20) + 40,
					r2, g2, b2, 255);
				
				bricks = brick_cells.get(index, null);
				if (bricks != null) {
					for (brick : bricks) {
						bx = $floor(origin_x + (brick.x - brick.y) * 40);
						by_base = origin_y + (brick.x + brick.y - brick.z) * 20;
						by_shadow = $floor(by_base);
						by = $floor(by_base - brick.z * 20);
						
						$gfx_draw_ellipse(bx - 5, $floor(by_base) - 2, 10, 5, 0, 0, 0, 190);
						$gfx_draw_ellipse(bx - 5, by - 5, 10, 10, 255, 255, 255, 255);
					}
				}
				
				++index;
			}
		}
	}
}
