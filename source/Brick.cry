GRAVITY = -.025;

class Brick {
	constructor(start_x, start_y, start_z, target_x, target_y, water_surface_z, velocity_ratio) {
		this.x = start_x;
		this.y = start_y;
		this.z = start_z;
		
		// z = z_start + v0 * t + a * t^2 / 2
		// t = 2 seconds = FPS * 2
		// water_surface_z = start_z + ??? * t + GRAVITY * t * t / 2
		
		t = FPS * 2.0 / velocity_ratio;
		
		this.vz = (water_surface_z - start_z - GRAVITY * t ** 2 / 2.0) / t;
		
		this.vx = (target_x - this.x) / t;
		this.vy = (target_y - this.y) / t;
		
		this.dead = false;
		this.hit_water = false;
		this.immunity_countdown = -1;
	}
	
	function update(fluid) {
		old_x = this.x;
		old_y = this.y;
		old_z = this.z;
		
		this.x += this.vx;
		this.y += this.vy;
		this.z += this.vz;
		
		this.immunity_countdown--;
		
		this.vz += GRAVITY;
		
		if (this.x < 0 || this.y < 0 || this.x >= fluid.width - 1 || this.y >= fluid.height - 1) {
			this.dead = true;
			return;
		}
		
		z = fluid.get_z_at(this.x, this.y);
		if (z > this.z) {
			
			vect = fluid.get_action_vector_at(this.x, this.y);
			
			if (vect != null) {
				this.vx = vect[0] / 10.0;
				this.vy = vect[1] / 10.0;
				this.z = z + 1;
				sev = fluid.get_action_severity_at(this.x, this.y) / 2;
				this.vz = sev;
				this.immunity_countdown = 5;
			} else if (this.immunity_countdown > 0) {
				this.z = z + 1;
			} else {
				this.dead = true;
				this.hit_water = true;
			}
		}
	}
}
